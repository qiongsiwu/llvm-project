// NOTE: Assertions have been autogenerated by utils/update_cc_test_checks.py UTC_ARGS: --replace-value-regex "!annotation ![0-9]+" "!tbaa ![0-9]+" "!tbaa\.struct ![0-9]+" "!nosanitize ![0-9]+" "!srcloc ![0-9]+"
// RUN: %clang_cc1 -O2 -triple x86_64 -fbounds-safety -emit-llvm %s -o - | FileCheck %s
// RUN: %clang_cc1 -O2 -triple x86_64 -fbounds-safety -x objective-c -fbounds-attributes-objc-experimental -emit-llvm %s -o - | FileCheck %s

#include <ptrcheck.h>

static const struct {
  int _dummy;
  int ints[3];
} foo = {
    0,
    {1, 2, 3},
};

// CHECK-LABEL: @good(
// CHECK-NEXT:  cont8.2:
// CHECK-NEXT:    ret ptr getelementptr inbounds (i8, ptr @foo, i64 4)
//
const int *__terminated_by(3) good(void) {
  const int *__indexable p = foo.ints;
  return __unsafe_terminated_by_from_indexable(3, p);
}

// CHECK-LABEL: @good_2(
// CHECK-NEXT:  cont8.1:
// CHECK-NEXT:    ret ptr getelementptr inbounds (i8, ptr @foo, i64 4)
//
const int *__terminated_by(2) good_2(void) {
  const int *__indexable p = foo.ints;
  return __unsafe_terminated_by_from_indexable(2, p);
}

// CHECK-LABEL: @bad_null(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    tail call void @llvm.ubsantrap(i8 25) #[[ATTR3:[0-9]+]], {{!annotation ![0-9]+}}
// CHECK-NEXT:    unreachable, {{!annotation ![0-9]+}}
//
int *__null_terminated bad_null(void) {
  int *__indexable p = 0;
  return __unsafe_null_terminated_from_indexable(p);
}

// CHECK-LABEL: @bad_no_term(
// CHECK-NEXT:  trap:
// CHECK-NEXT:    tail call void @llvm.ubsantrap(i8 25) #[[ATTR3]], {{!annotation ![0-9]+}}
// CHECK-NEXT:    unreachable, {{!annotation ![0-9]+}}
//
const int *__null_terminated bad_no_term(void) {
  const int *__indexable p = foo.ints;
  return __unsafe_null_terminated_from_indexable(p);
}

// CHECK-LABEL: @bad_bidi_lower_bound(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    tail call void @llvm.ubsantrap(i8 25) #[[ATTR3]], {{!annotation ![0-9]+}}
// CHECK-NEXT:    unreachable, {{!annotation ![0-9]+}}
//
const int *__terminated_by(3) bad_bidi_lower_bound(void) {
  // Conversion of __bidi_indexable to __indexable should fail.
  const int *__bidi_indexable p = foo.ints;
  p--;
  return __unsafe_terminated_by_from_indexable(3, p);
}
