// NOTE: Assertions have been autogenerated by utils/update_cc_test_checks.py UTC_ARGS: --replace-value-regex "!annotation ![0-9]+" "!tbaa ![0-9]+" "!tbaa\.struct ![0-9]+" "!nosanitize ![0-9]+" "!srcloc ![0-9]+" --prefix-filecheck-ir-name TMP_
// RUN: %clang_cc1 -O0 -triple arm64-apple-iphoneos -fbounds-safety -emit-llvm %s -o - | FileCheck %s
// RUN: %clang_cc1 -O0 -triple arm64-apple-iphoneos -fbounds-safety -x objective-c -fbounds-attributes-objc-experimental -emit-llvm %s -o - | FileCheck %s

#include <ptrcheck.h>

typedef struct {
  int count;
  int elems[__counted_by(count)];
} flex_t;

// CHECK-LABEL: @pointer_assign(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[FLEX_ADDR:%.*]] = alloca ptr, align 8
// CHECK-NEXT:    [[B:%.*]] = alloca %"__bounds_safety::wide_ptr.bidi_indexable", align 8
// CHECK-NEXT:    store ptr [[FLEX:%.*]], ptr [[FLEX_ADDR]], align 8
// CHECK-NEXT:    [[TMP0:%.*]] = load ptr, ptr [[FLEX_ADDR]], align 8
// CHECK-NEXT:    [[TMP1:%.*]] = icmp ne ptr [[TMP0]], null, {{!annotation ![0-9]+}}
// CHECK-NEXT:    br i1 [[TMP1]], label [[BOUNDSCHECK_NOTNULL:%.*]], label [[BOUNDSCHECK_NULL:%.*]], {{!annotation ![0-9]+}}
// CHECK:       boundscheck.notnull:
// CHECK-NEXT:    [[ELEMS:%.*]] = getelementptr inbounds [[STRUCT_FLEX_T:%.*]], ptr [[TMP0]], i32 0, i32 1
// CHECK-NEXT:    [[ARRAYDECAY:%.*]] = getelementptr inbounds [0 x i32], ptr [[ELEMS]], i64 0, i64 0
// CHECK-NEXT:    [[COUNT:%.*]] = getelementptr inbounds [[STRUCT_FLEX_T]], ptr [[TMP0]], i32 0, i32 0
// CHECK-NEXT:    [[TMP2:%.*]] = load i32, ptr [[COUNT]], align 4
// CHECK-NEXT:    [[IDX_EXT:%.*]] = sext i32 [[TMP2]] to i64
// CHECK-NEXT:    [[ADD_PTR:%.*]] = getelementptr inbounds i32, ptr [[ARRAYDECAY]], i64 [[IDX_EXT]]
// CHECK-NEXT:    [[TMP3:%.*]] = getelementptr inbounds %"__bounds_safety::wide_ptr.bidi_indexable", ptr [[B]], i32 0, i32 0
// CHECK-NEXT:    store ptr [[TMP0]], ptr [[TMP3]], align 8
// CHECK-NEXT:    [[TMP4:%.*]] = getelementptr inbounds %"__bounds_safety::wide_ptr.bidi_indexable", ptr [[B]], i32 0, i32 1
// CHECK-NEXT:    store ptr [[ADD_PTR]], ptr [[TMP4]], align 8
// CHECK-NEXT:    [[TMP5:%.*]] = getelementptr inbounds %"__bounds_safety::wide_ptr.bidi_indexable", ptr [[B]], i32 0, i32 2
// CHECK-NEXT:    store ptr [[TMP0]], ptr [[TMP5]], align 8
// CHECK-NEXT:    br label [[BOUNDSCHECK_CONT:%.*]]
// CHECK:       boundscheck.null:
// CHECK-NEXT:    [[TMP6:%.*]] = getelementptr inbounds %"__bounds_safety::wide_ptr.bidi_indexable", ptr [[B]], i32 0, i32 0
// CHECK-NEXT:    store ptr null, ptr [[TMP6]], align 8
// CHECK-NEXT:    [[TMP7:%.*]] = getelementptr inbounds %"__bounds_safety::wide_ptr.bidi_indexable", ptr [[B]], i32 0, i32 1
// CHECK-NEXT:    store ptr null, ptr [[TMP7]], align 8
// CHECK-NEXT:    [[TMP8:%.*]] = getelementptr inbounds %"__bounds_safety::wide_ptr.bidi_indexable", ptr [[B]], i32 0, i32 2
// CHECK-NEXT:    store ptr null, ptr [[TMP8]], align 8
// CHECK-NEXT:    br label [[BOUNDSCHECK_CONT]]
// CHECK:       boundscheck.cont:
// CHECK-NEXT:    ret void
//
void pointer_assign(flex_t *flex) {
  flex_t *b = flex;
}

// CHECK-LABEL: @pointer_assign_single(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[FLEX_ADDR:%.*]] = alloca ptr, align 8
// CHECK-NEXT:    [[S:%.*]] = alloca ptr, align 8
// CHECK-NEXT:    [[AGG_TEMP:%.*]] = alloca %"__bounds_safety::wide_ptr.bidi_indexable", align 8
// CHECK-NEXT:    [[AGG_TEMP1:%.*]] = alloca %"__bounds_safety::wide_ptr.bidi_indexable", align 8
// CHECK-NEXT:    [[AGG_TEMP2:%.*]] = alloca %"__bounds_safety::wide_ptr.bidi_indexable", align 8
// CHECK-NEXT:    [[AGG_TEMP3:%.*]] = alloca %"__bounds_safety::wide_ptr.bidi_indexable", align 8
// CHECK-NEXT:    [[AGG_TEMP16:%.*]] = alloca %"__bounds_safety::wide_ptr.bidi_indexable", align 8
// CHECK-NEXT:    store ptr [[FLEX:%.*]], ptr [[FLEX_ADDR]], align 8
// CHECK-NEXT:    [[TMP0:%.*]] = load ptr, ptr [[FLEX_ADDR]], align 8
// CHECK-NEXT:    [[TMP1:%.*]] = icmp ne ptr [[TMP0]], null, {{!annotation ![0-9]+}}
// CHECK-NEXT:    br i1 [[TMP1]], label [[BOUNDSCHECK_NOTNULL:%.*]], label [[BOUNDSCHECK_NULL:%.*]], {{!annotation ![0-9]+}}
// CHECK:       boundscheck.notnull:
// CHECK-NEXT:    [[ELEMS:%.*]] = getelementptr inbounds [[STRUCT_FLEX_T:%.*]], ptr [[TMP0]], i32 0, i32 1
// CHECK-NEXT:    [[ARRAYDECAY:%.*]] = getelementptr inbounds [0 x i32], ptr [[ELEMS]], i64 0, i64 0
// CHECK-NEXT:    [[COUNT:%.*]] = getelementptr inbounds [[STRUCT_FLEX_T]], ptr [[TMP0]], i32 0, i32 0
// CHECK-NEXT:    [[TMP2:%.*]] = load i32, ptr [[COUNT]], align 4
// CHECK-NEXT:    [[IDX_EXT:%.*]] = sext i32 [[TMP2]] to i64
// CHECK-NEXT:    [[ADD_PTR:%.*]] = getelementptr inbounds i32, ptr [[ARRAYDECAY]], i64 [[IDX_EXT]]
// CHECK-NEXT:    [[TMP3:%.*]] = getelementptr inbounds %"__bounds_safety::wide_ptr.bidi_indexable", ptr [[AGG_TEMP]], i32 0, i32 0
// CHECK-NEXT:    store ptr [[TMP0]], ptr [[TMP3]], align 8
// CHECK-NEXT:    [[TMP4:%.*]] = getelementptr inbounds %"__bounds_safety::wide_ptr.bidi_indexable", ptr [[AGG_TEMP]], i32 0, i32 1
// CHECK-NEXT:    store ptr [[ADD_PTR]], ptr [[TMP4]], align 8
// CHECK-NEXT:    [[TMP5:%.*]] = getelementptr inbounds %"__bounds_safety::wide_ptr.bidi_indexable", ptr [[AGG_TEMP]], i32 0, i32 2
// CHECK-NEXT:    store ptr [[TMP0]], ptr [[TMP5]], align 8
// CHECK-NEXT:    br label [[BOUNDSCHECK_CONT:%.*]]
// CHECK:       boundscheck.null:
// CHECK-NEXT:    [[TMP6:%.*]] = getelementptr inbounds %"__bounds_safety::wide_ptr.bidi_indexable", ptr [[AGG_TEMP]], i32 0, i32 0
// CHECK-NEXT:    store ptr null, ptr [[TMP6]], align 8
// CHECK-NEXT:    [[TMP7:%.*]] = getelementptr inbounds %"__bounds_safety::wide_ptr.bidi_indexable", ptr [[AGG_TEMP]], i32 0, i32 1
// CHECK-NEXT:    store ptr null, ptr [[TMP7]], align 8
// CHECK-NEXT:    [[TMP8:%.*]] = getelementptr inbounds %"__bounds_safety::wide_ptr.bidi_indexable", ptr [[AGG_TEMP]], i32 0, i32 2
// CHECK-NEXT:    store ptr null, ptr [[TMP8]], align 8
// CHECK-NEXT:    br label [[BOUNDSCHECK_CONT]]
// CHECK:       boundscheck.cont:
// CHECK-NEXT:    call void @llvm.memcpy.p0.p0.i64(ptr align 8 [[AGG_TEMP2]], ptr align 8 [[AGG_TEMP]], i64 24, i1 false)
// CHECK-NEXT:    [[WIDE_PTR_PTR_ADDR:%.*]] = getelementptr inbounds %"__bounds_safety::wide_ptr.bidi_indexable", ptr [[AGG_TEMP2]], i32 0, i32 0
// CHECK-NEXT:    [[WIDE_PTR_PTR:%.*]] = load ptr, ptr [[WIDE_PTR_PTR_ADDR]], align 8
// CHECK-NEXT:    [[WIDE_PTR_UB_ADDR:%.*]] = getelementptr inbounds %"__bounds_safety::wide_ptr.bidi_indexable", ptr [[AGG_TEMP2]], i32 0, i32 1
// CHECK-NEXT:    [[WIDE_PTR_UB:%.*]] = load ptr, ptr [[WIDE_PTR_UB_ADDR]], align 8
// CHECK-NEXT:    [[WIDE_PTR_LB_ADDR:%.*]] = getelementptr inbounds %"__bounds_safety::wide_ptr.bidi_indexable", ptr [[AGG_TEMP2]], i32 0, i32 2
// CHECK-NEXT:    [[WIDE_PTR_LB:%.*]] = load ptr, ptr [[WIDE_PTR_LB_ADDR]], align 8
// CHECK-NEXT:    [[FLEX_BASE_NULL_CHECK:%.*]] = icmp ne ptr [[WIDE_PTR_PTR]], null, {{!annotation ![0-9]+}}
// CHECK-NEXT:    br i1 [[FLEX_BASE_NULL_CHECK]], label [[FLEX_BASE_NONNULL:%.*]], label [[CONT35:%.*]], {{!annotation ![0-9]+}}
// CHECK:       flex.base.nonnull:
// CHECK-NEXT:    [[TMP9:%.*]] = getelementptr [[STRUCT_FLEX_T]], ptr [[WIDE_PTR_PTR]], i64 1
// CHECK-NEXT:    [[TMP10:%.*]] = icmp ule ptr [[WIDE_PTR_PTR]], [[TMP9]], {{!annotation ![0-9]+}}
// CHECK-NEXT:    br i1 [[TMP10]], label [[CONT:%.*]], label [[TRAP:%.*]], {{!annotation ![0-9]+}}
// CHECK:       trap:
// CHECK-NEXT:    call void @llvm.ubsantrap(i8 25) #[[ATTR3:[0-9]+]], {{!annotation ![0-9]+}}
// CHECK-NEXT:    unreachable
// CHECK:       cont:
// CHECK-NEXT:    call void @llvm.memcpy.p0.p0.i64(ptr align 8 [[AGG_TEMP3]], ptr align 8 [[AGG_TEMP]], i64 24, i1 false)
// CHECK-NEXT:    [[WIDE_PTR_PTR_ADDR4:%.*]] = getelementptr inbounds %"__bounds_safety::wide_ptr.bidi_indexable", ptr [[AGG_TEMP3]], i32 0, i32 0
// CHECK-NEXT:    [[WIDE_PTR_PTR5:%.*]] = load ptr, ptr [[WIDE_PTR_PTR_ADDR4]], align 8
// CHECK-NEXT:    [[WIDE_PTR_UB_ADDR6:%.*]] = getelementptr inbounds %"__bounds_safety::wide_ptr.bidi_indexable", ptr [[AGG_TEMP3]], i32 0, i32 1
// CHECK-NEXT:    [[WIDE_PTR_UB7:%.*]] = load ptr, ptr [[WIDE_PTR_UB_ADDR6]], align 8
// CHECK-NEXT:    [[WIDE_PTR_LB_ADDR8:%.*]] = getelementptr inbounds %"__bounds_safety::wide_ptr.bidi_indexable", ptr [[AGG_TEMP3]], i32 0, i32 2
// CHECK-NEXT:    [[WIDE_PTR_LB9:%.*]] = load ptr, ptr [[WIDE_PTR_LB_ADDR8]], align 8
// CHECK-NEXT:    [[TMP11:%.*]] = getelementptr [[STRUCT_FLEX_T]], ptr [[WIDE_PTR_PTR5]], i64 1
// CHECK-NEXT:    [[TMP12:%.*]] = icmp ule ptr [[TMP11]], [[WIDE_PTR_UB7]], {{!annotation ![0-9]+}}
// CHECK-NEXT:    br i1 [[TMP12]], label [[CONT11:%.*]], label [[TRAP10:%.*]], {{!annotation ![0-9]+}}
// CHECK:       trap10:
// CHECK-NEXT:    call void @llvm.ubsantrap(i8 25) #[[ATTR3]], {{!annotation ![0-9]+}}
// CHECK-NEXT:    unreachable
// CHECK:       cont11:
// CHECK-NEXT:    [[TMP13:%.*]] = icmp ule ptr [[WIDE_PTR_LB9]], [[WIDE_PTR_PTR5]], {{!annotation ![0-9]+}}
// CHECK-NEXT:    br i1 [[TMP13]], label [[CONT13:%.*]], label [[TRAP12:%.*]], {{!annotation ![0-9]+}}
// CHECK:       trap12:
// CHECK-NEXT:    call void @llvm.ubsantrap(i8 25) #[[ATTR3]], {{!annotation ![0-9]+}}
// CHECK-NEXT:    unreachable
// CHECK:       cont13:
// CHECK-NEXT:    [[ELEMS14:%.*]] = getelementptr inbounds [[STRUCT_FLEX_T]], ptr [[WIDE_PTR_PTR5]], i32 0, i32 1
// CHECK-NEXT:    [[ARRAYDECAY15:%.*]] = getelementptr inbounds [0 x i32], ptr [[ELEMS14]], i64 0, i64 0
// CHECK-NEXT:    call void @llvm.memcpy.p0.p0.i64(ptr align 8 [[AGG_TEMP16]], ptr align 8 [[AGG_TEMP]], i64 24, i1 false)
// CHECK-NEXT:    [[WIDE_PTR_PTR_ADDR17:%.*]] = getelementptr inbounds %"__bounds_safety::wide_ptr.bidi_indexable", ptr [[AGG_TEMP16]], i32 0, i32 0
// CHECK-NEXT:    [[WIDE_PTR_PTR18:%.*]] = load ptr, ptr [[WIDE_PTR_PTR_ADDR17]], align 8
// CHECK-NEXT:    [[WIDE_PTR_UB_ADDR19:%.*]] = getelementptr inbounds %"__bounds_safety::wide_ptr.bidi_indexable", ptr [[AGG_TEMP16]], i32 0, i32 1
// CHECK-NEXT:    [[WIDE_PTR_UB20:%.*]] = load ptr, ptr [[WIDE_PTR_UB_ADDR19]], align 8
// CHECK-NEXT:    [[WIDE_PTR_LB_ADDR21:%.*]] = getelementptr inbounds %"__bounds_safety::wide_ptr.bidi_indexable", ptr [[AGG_TEMP16]], i32 0, i32 2
// CHECK-NEXT:    [[WIDE_PTR_LB22:%.*]] = load ptr, ptr [[WIDE_PTR_LB_ADDR21]], align 8
// CHECK-NEXT:    [[TMP14:%.*]] = getelementptr [[STRUCT_FLEX_T]], ptr [[WIDE_PTR_PTR18]], i64 1
// CHECK-NEXT:    [[TMP15:%.*]] = icmp ule ptr [[TMP14]], [[WIDE_PTR_UB20]], {{!annotation ![0-9]+}}
// CHECK-NEXT:    br i1 [[TMP15]], label [[CONT24:%.*]], label [[TRAP23:%.*]], {{!annotation ![0-9]+}}
// CHECK:       trap23:
// CHECK-NEXT:    call void @llvm.ubsantrap(i8 25) #[[ATTR3]], {{!annotation ![0-9]+}}
// CHECK-NEXT:    unreachable
// CHECK:       cont24:
// CHECK-NEXT:    [[TMP16:%.*]] = icmp ule ptr [[WIDE_PTR_LB22]], [[WIDE_PTR_PTR18]], {{!annotation ![0-9]+}}
// CHECK-NEXT:    br i1 [[TMP16]], label [[CONT26:%.*]], label [[TRAP25:%.*]], {{!annotation ![0-9]+}}
// CHECK:       trap25:
// CHECK-NEXT:    call void @llvm.ubsantrap(i8 25) #[[ATTR3]], {{!annotation ![0-9]+}}
// CHECK-NEXT:    unreachable
// CHECK:       cont26:
// CHECK-NEXT:    [[COUNT27:%.*]] = getelementptr inbounds [[STRUCT_FLEX_T]], ptr [[WIDE_PTR_PTR18]], i32 0, i32 0
// CHECK-NEXT:    [[TMP17:%.*]] = load i32, ptr [[COUNT27]], align 4
// CHECK-NEXT:    [[FLEX_COUNT_MINUS:%.*]] = icmp sle i32 0, [[TMP17]], {{!annotation ![0-9]+}}
// CHECK-NEXT:    br i1 [[FLEX_COUNT_MINUS]], label [[CONT29:%.*]], label [[TRAP28:%.*]], {{!annotation ![0-9]+}}
// CHECK:       trap28:
// CHECK-NEXT:    call void @llvm.ubsantrap(i8 25) #[[ATTR3]], {{!annotation ![0-9]+}}
// CHECK-NEXT:    unreachable, {{!annotation ![0-9]+}}
// CHECK:       cont29:
// CHECK-NEXT:    [[TMP18:%.*]] = icmp ule ptr [[ARRAYDECAY15]], [[WIDE_PTR_UB]], {{!annotation ![0-9]+}}
// CHECK-NEXT:    br i1 [[TMP18]], label [[CONT31:%.*]], label [[TRAP30:%.*]], {{!annotation ![0-9]+}}
// CHECK:       trap30:
// CHECK-NEXT:    call void @llvm.ubsantrap(i8 25) #[[ATTR3]], {{!annotation ![0-9]+}}
// CHECK-NEXT:    unreachable, {{!annotation ![0-9]+}}
// CHECK:       cont31:
// CHECK-NEXT:    [[TMP19:%.*]] = icmp uge ptr [[WIDE_PTR_PTR]], [[WIDE_PTR_LB]], {{!annotation ![0-9]+}}
// CHECK-NEXT:    br i1 [[TMP19]], label [[CONT33:%.*]], label [[TRAP32:%.*]], {{!annotation ![0-9]+}}
// CHECK:       trap32:
// CHECK-NEXT:    call void @llvm.ubsantrap(i8 25) #[[ATTR3]], {{!annotation ![0-9]+}}
// CHECK-NEXT:    unreachable, {{!annotation ![0-9]+}}
// CHECK:       cont33:
// CHECK-NEXT:    [[UPPER_INTPTR:%.*]] = ptrtoint ptr [[WIDE_PTR_UB]] to i64, {{!annotation ![0-9]+}}
// CHECK-NEXT:    [[FAM_INTPTR:%.*]] = ptrtoint ptr [[ARRAYDECAY15]] to i64, {{!annotation ![0-9]+}}
// CHECK-NEXT:    [[FLEX_AVAIL_COUNT:%.*]] = sub nuw i64 [[UPPER_INTPTR]], [[FAM_INTPTR]], {{!annotation ![0-9]+}}
// CHECK-NEXT:    [[FLEX_AVAIL_COUNT_DIV:%.*]] = sdiv exact i64 [[FLEX_AVAIL_COUNT]], 4, {{!annotation ![0-9]+}}
// CHECK-NEXT:    [[FLEX_COUNT_INTPTR:%.*]] = zext i32 [[TMP17]] to i64, {{!annotation ![0-9]+}}
// CHECK-NEXT:    [[FLEX_COUNT_CHECK:%.*]] = icmp ule i64 [[FLEX_COUNT_INTPTR]], [[FLEX_AVAIL_COUNT_DIV]], {{!annotation ![0-9]+}}
// CHECK-NEXT:    br i1 [[FLEX_COUNT_CHECK]], label [[CONT35]], label [[TRAP34:%.*]], {{!annotation ![0-9]+}}
// CHECK:       trap34:
// CHECK-NEXT:    call void @llvm.ubsantrap(i8 25) #[[ATTR3]], {{!annotation ![0-9]+}}
// CHECK-NEXT:    unreachable, {{!annotation ![0-9]+}}
// CHECK:       cont35:
// CHECK-NEXT:    call void @llvm.memcpy.p0.p0.i64(ptr align 8 [[AGG_TEMP1]], ptr align 8 [[AGG_TEMP]], i64 24, i1 false)
// CHECK-NEXT:    [[WIDE_PTR_PTR_ADDR36:%.*]] = getelementptr inbounds %"__bounds_safety::wide_ptr.bidi_indexable", ptr [[AGG_TEMP1]], i32 0, i32 0
// CHECK-NEXT:    [[WIDE_PTR_PTR37:%.*]] = load ptr, ptr [[WIDE_PTR_PTR_ADDR36]], align 8
// CHECK-NEXT:    [[WIDE_PTR_UB_ADDR38:%.*]] = getelementptr inbounds %"__bounds_safety::wide_ptr.bidi_indexable", ptr [[AGG_TEMP1]], i32 0, i32 1
// CHECK-NEXT:    [[WIDE_PTR_UB39:%.*]] = load ptr, ptr [[WIDE_PTR_UB_ADDR38]], align 8
// CHECK-NEXT:    [[WIDE_PTR_LB_ADDR40:%.*]] = getelementptr inbounds %"__bounds_safety::wide_ptr.bidi_indexable", ptr [[AGG_TEMP1]], i32 0, i32 2
// CHECK-NEXT:    [[WIDE_PTR_LB41:%.*]] = load ptr, ptr [[WIDE_PTR_LB_ADDR40]], align 8
// CHECK-NEXT:    [[TMP20:%.*]] = icmp ne ptr [[WIDE_PTR_PTR37]], null, {{!annotation ![0-9]+}}
// CHECK-NEXT:    br i1 [[TMP20]], label [[BOUNDSCHECK_NOTNULL42:%.*]], label [[CONT46:%.*]], {{!annotation ![0-9]+}}
// CHECK:       boundscheck.notnull42:
// CHECK-NEXT:    [[TMP21:%.*]] = icmp ult ptr [[WIDE_PTR_PTR37]], [[WIDE_PTR_UB39]], {{!annotation ![0-9]+}}
// CHECK-NEXT:    br i1 [[TMP21]], label [[CONT44:%.*]], label [[TRAP43:%.*]], {{!annotation ![0-9]+}}
// CHECK:       trap43:
// CHECK-NEXT:    call void @llvm.ubsantrap(i8 25) #[[ATTR3]], {{!annotation ![0-9]+}}
// CHECK-NEXT:    unreachable
// CHECK:       cont44:
// CHECK-NEXT:    [[TMP22:%.*]] = icmp uge ptr [[WIDE_PTR_PTR37]], [[WIDE_PTR_LB41]], {{!annotation ![0-9]+}}
// CHECK-NEXT:    br i1 [[TMP22]], label [[CONT46]], label [[TRAP45:%.*]], {{!annotation ![0-9]+}}
// CHECK:       trap45:
// CHECK-NEXT:    call void @llvm.ubsantrap(i8 25) #[[ATTR3]], {{!annotation ![0-9]+}}
// CHECK-NEXT:    unreachable
// CHECK:       cont46:
// CHECK-NEXT:    store ptr [[WIDE_PTR_PTR37]], ptr [[S]], align 8
// CHECK-NEXT:    ret void
//
void pointer_assign_single(flex_t *flex) {
  flex_t *__single s = flex;
}

// CHECK-LABEL: @pointer_and_count_assign(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[FLEX_ADDR:%.*]] = alloca ptr, align 8
// CHECK-NEXT:    [[B:%.*]] = alloca %"__bounds_safety::wide_ptr.bidi_indexable", align 8
// CHECK-NEXT:    [[AGG_TEMP:%.*]] = alloca %"__bounds_safety::wide_ptr.bidi_indexable", align 8
// CHECK-NEXT:    store ptr [[FLEX:%.*]], ptr [[FLEX_ADDR]], align 8
// CHECK-NEXT:    [[TMP0:%.*]] = load ptr, ptr [[FLEX_ADDR]], align 8
// CHECK-NEXT:    [[TMP1:%.*]] = icmp ne ptr [[TMP0]], null, {{!annotation ![0-9]+}}
// CHECK-NEXT:    br i1 [[TMP1]], label [[BOUNDSCHECK_NOTNULL:%.*]], label [[BOUNDSCHECK_NULL:%.*]], {{!annotation ![0-9]+}}
// CHECK:       boundscheck.notnull:
// CHECK-NEXT:    [[ELEMS:%.*]] = getelementptr inbounds [[STRUCT_FLEX_T:%.*]], ptr [[TMP0]], i32 0, i32 1
// CHECK-NEXT:    [[ARRAYDECAY:%.*]] = getelementptr inbounds [0 x i32], ptr [[ELEMS]], i64 0, i64 0
// CHECK-NEXT:    [[COUNT:%.*]] = getelementptr inbounds [[STRUCT_FLEX_T]], ptr [[TMP0]], i32 0, i32 0
// CHECK-NEXT:    [[TMP2:%.*]] = load i32, ptr [[COUNT]], align 4
// CHECK-NEXT:    [[IDX_EXT:%.*]] = sext i32 [[TMP2]] to i64
// CHECK-NEXT:    [[ADD_PTR:%.*]] = getelementptr inbounds i32, ptr [[ARRAYDECAY]], i64 [[IDX_EXT]]
// CHECK-NEXT:    [[TMP3:%.*]] = getelementptr inbounds %"__bounds_safety::wide_ptr.bidi_indexable", ptr [[B]], i32 0, i32 0
// CHECK-NEXT:    store ptr [[TMP0]], ptr [[TMP3]], align 8
// CHECK-NEXT:    [[TMP4:%.*]] = getelementptr inbounds %"__bounds_safety::wide_ptr.bidi_indexable", ptr [[B]], i32 0, i32 1
// CHECK-NEXT:    store ptr [[ADD_PTR]], ptr [[TMP4]], align 8
// CHECK-NEXT:    [[TMP5:%.*]] = getelementptr inbounds %"__bounds_safety::wide_ptr.bidi_indexable", ptr [[B]], i32 0, i32 2
// CHECK-NEXT:    store ptr [[TMP0]], ptr [[TMP5]], align 8
// CHECK-NEXT:    br label [[BOUNDSCHECK_CONT:%.*]]
// CHECK:       boundscheck.null:
// CHECK-NEXT:    [[TMP6:%.*]] = getelementptr inbounds %"__bounds_safety::wide_ptr.bidi_indexable", ptr [[B]], i32 0, i32 0
// CHECK-NEXT:    store ptr null, ptr [[TMP6]], align 8
// CHECK-NEXT:    [[TMP7:%.*]] = getelementptr inbounds %"__bounds_safety::wide_ptr.bidi_indexable", ptr [[B]], i32 0, i32 1
// CHECK-NEXT:    store ptr null, ptr [[TMP7]], align 8
// CHECK-NEXT:    [[TMP8:%.*]] = getelementptr inbounds %"__bounds_safety::wide_ptr.bidi_indexable", ptr [[B]], i32 0, i32 2
// CHECK-NEXT:    store ptr null, ptr [[TMP8]], align 8
// CHECK-NEXT:    br label [[BOUNDSCHECK_CONT]]
// CHECK:       boundscheck.cont:
// CHECK-NEXT:    call void @llvm.memcpy.p0.p0.i64(ptr align 8 [[AGG_TEMP]], ptr align 8 [[B]], i64 24, i1 false)
// CHECK-NEXT:    [[WIDE_PTR_PTR_ADDR:%.*]] = getelementptr inbounds %"__bounds_safety::wide_ptr.bidi_indexable", ptr [[AGG_TEMP]], i32 0, i32 0
// CHECK-NEXT:    [[WIDE_PTR_PTR:%.*]] = load ptr, ptr [[WIDE_PTR_PTR_ADDR]], align 8
// CHECK-NEXT:    [[WIDE_PTR_UB_ADDR:%.*]] = getelementptr inbounds %"__bounds_safety::wide_ptr.bidi_indexable", ptr [[AGG_TEMP]], i32 0, i32 1
// CHECK-NEXT:    [[WIDE_PTR_UB:%.*]] = load ptr, ptr [[WIDE_PTR_UB_ADDR]], align 8
// CHECK-NEXT:    [[WIDE_PTR_LB_ADDR:%.*]] = getelementptr inbounds %"__bounds_safety::wide_ptr.bidi_indexable", ptr [[AGG_TEMP]], i32 0, i32 2
// CHECK-NEXT:    [[WIDE_PTR_LB:%.*]] = load ptr, ptr [[WIDE_PTR_LB_ADDR]], align 8
// CHECK-NEXT:    [[TMP9:%.*]] = getelementptr [[STRUCT_FLEX_T]], ptr [[WIDE_PTR_PTR]], i64 1
// CHECK-NEXT:    [[TMP10:%.*]] = icmp ule ptr [[TMP9]], [[WIDE_PTR_UB]], {{!annotation ![0-9]+}}
// CHECK-NEXT:    br i1 [[TMP10]], label [[CONT:%.*]], label [[TRAP:%.*]], {{!annotation ![0-9]+}}
// CHECK:       trap:
// CHECK-NEXT:    call void @llvm.ubsantrap(i8 25) #[[ATTR3]], {{!annotation ![0-9]+}}
// CHECK-NEXT:    unreachable
// CHECK:       cont:
// CHECK-NEXT:    [[TMP11:%.*]] = icmp ule ptr [[WIDE_PTR_LB]], [[WIDE_PTR_PTR]], {{!annotation ![0-9]+}}
// CHECK-NEXT:    br i1 [[TMP11]], label [[CONT2:%.*]], label [[TRAP1:%.*]], {{!annotation ![0-9]+}}
// CHECK:       trap1:
// CHECK-NEXT:    call void @llvm.ubsantrap(i8 25) #[[ATTR3]], {{!annotation ![0-9]+}}
// CHECK-NEXT:    unreachable
// CHECK:       cont2:
// CHECK-NEXT:    [[COUNT3:%.*]] = getelementptr inbounds [[STRUCT_FLEX_T]], ptr [[WIDE_PTR_PTR]], i32 0, i32 0
// CHECK-NEXT:    store i32 10, ptr [[COUNT3]], align 4
// CHECK-NEXT:    ret void
//
void pointer_and_count_assign(flex_t *flex) {
  flex_t *b = flex;
  b->count = 10;
}

// CHECK-LABEL: @pointer_and_count_assign_single(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[FLEX_ADDR:%.*]] = alloca ptr, align 8
// CHECK-NEXT:    [[B:%.*]] = alloca ptr, align 8
// CHECK-NEXT:    [[AGG_TEMP:%.*]] = alloca %"__bounds_safety::wide_ptr.bidi_indexable", align 8
// CHECK-NEXT:    [[AGG_TEMP1:%.*]] = alloca %"__bounds_safety::wide_ptr.bidi_indexable", align 8
// CHECK-NEXT:    [[AGG_TEMP2:%.*]] = alloca %"__bounds_safety::wide_ptr.bidi_indexable", align 8
// CHECK-NEXT:    [[AGG_TEMP3:%.*]] = alloca %"__bounds_safety::wide_ptr.bidi_indexable", align 8
// CHECK-NEXT:    store ptr [[FLEX:%.*]], ptr [[FLEX_ADDR]], align 8
// CHECK-NEXT:    [[TMP0:%.*]] = load ptr, ptr [[FLEX_ADDR]], align 8
// CHECK-NEXT:    [[TMP1:%.*]] = icmp ne ptr [[TMP0]], null, {{!annotation ![0-9]+}}
// CHECK-NEXT:    br i1 [[TMP1]], label [[BOUNDSCHECK_NOTNULL:%.*]], label [[BOUNDSCHECK_NULL:%.*]], {{!annotation ![0-9]+}}
// CHECK:       boundscheck.notnull:
// CHECK-NEXT:    [[ELEMS:%.*]] = getelementptr inbounds [[STRUCT_FLEX_T:%.*]], ptr [[TMP0]], i32 0, i32 1
// CHECK-NEXT:    [[ARRAYDECAY:%.*]] = getelementptr inbounds [0 x i32], ptr [[ELEMS]], i64 0, i64 0
// CHECK-NEXT:    [[COUNT:%.*]] = getelementptr inbounds [[STRUCT_FLEX_T]], ptr [[TMP0]], i32 0, i32 0
// CHECK-NEXT:    [[TMP2:%.*]] = load i32, ptr [[COUNT]], align 4
// CHECK-NEXT:    [[IDX_EXT:%.*]] = sext i32 [[TMP2]] to i64
// CHECK-NEXT:    [[ADD_PTR:%.*]] = getelementptr inbounds i32, ptr [[ARRAYDECAY]], i64 [[IDX_EXT]]
// CHECK-NEXT:    [[TMP3:%.*]] = getelementptr inbounds %"__bounds_safety::wide_ptr.bidi_indexable", ptr [[AGG_TEMP]], i32 0, i32 0
// CHECK-NEXT:    store ptr [[TMP0]], ptr [[TMP3]], align 8
// CHECK-NEXT:    [[TMP4:%.*]] = getelementptr inbounds %"__bounds_safety::wide_ptr.bidi_indexable", ptr [[AGG_TEMP]], i32 0, i32 1
// CHECK-NEXT:    store ptr [[ADD_PTR]], ptr [[TMP4]], align 8
// CHECK-NEXT:    [[TMP5:%.*]] = getelementptr inbounds %"__bounds_safety::wide_ptr.bidi_indexable", ptr [[AGG_TEMP]], i32 0, i32 2
// CHECK-NEXT:    store ptr [[TMP0]], ptr [[TMP5]], align 8
// CHECK-NEXT:    br label [[BOUNDSCHECK_CONT:%.*]]
// CHECK:       boundscheck.null:
// CHECK-NEXT:    [[TMP6:%.*]] = getelementptr inbounds %"__bounds_safety::wide_ptr.bidi_indexable", ptr [[AGG_TEMP]], i32 0, i32 0
// CHECK-NEXT:    store ptr null, ptr [[TMP6]], align 8
// CHECK-NEXT:    [[TMP7:%.*]] = getelementptr inbounds %"__bounds_safety::wide_ptr.bidi_indexable", ptr [[AGG_TEMP]], i32 0, i32 1
// CHECK-NEXT:    store ptr null, ptr [[TMP7]], align 8
// CHECK-NEXT:    [[TMP8:%.*]] = getelementptr inbounds %"__bounds_safety::wide_ptr.bidi_indexable", ptr [[AGG_TEMP]], i32 0, i32 2
// CHECK-NEXT:    store ptr null, ptr [[TMP8]], align 8
// CHECK-NEXT:    br label [[BOUNDSCHECK_CONT]]
// CHECK:       boundscheck.cont:
// CHECK-NEXT:    call void @llvm.memcpy.p0.p0.i64(ptr align 8 [[AGG_TEMP2]], ptr align 8 [[AGG_TEMP]], i64 24, i1 false)
// CHECK-NEXT:    [[WIDE_PTR_PTR_ADDR:%.*]] = getelementptr inbounds %"__bounds_safety::wide_ptr.bidi_indexable", ptr [[AGG_TEMP2]], i32 0, i32 0
// CHECK-NEXT:    [[WIDE_PTR_PTR:%.*]] = load ptr, ptr [[WIDE_PTR_PTR_ADDR]], align 8
// CHECK-NEXT:    [[WIDE_PTR_UB_ADDR:%.*]] = getelementptr inbounds %"__bounds_safety::wide_ptr.bidi_indexable", ptr [[AGG_TEMP2]], i32 0, i32 1
// CHECK-NEXT:    [[WIDE_PTR_UB:%.*]] = load ptr, ptr [[WIDE_PTR_UB_ADDR]], align 8
// CHECK-NEXT:    [[WIDE_PTR_LB_ADDR:%.*]] = getelementptr inbounds %"__bounds_safety::wide_ptr.bidi_indexable", ptr [[AGG_TEMP2]], i32 0, i32 2
// CHECK-NEXT:    [[WIDE_PTR_LB:%.*]] = load ptr, ptr [[WIDE_PTR_LB_ADDR]], align 8
// CHECK-NEXT:    [[FLEX_BASE_NULL_CHECK:%.*]] = icmp ne ptr [[WIDE_PTR_PTR]], null, {{!annotation ![0-9]+}}
// CHECK-NEXT:    br i1 [[FLEX_BASE_NULL_CHECK]], label [[FLEX_BASE_NONNULL:%.*]], label [[CONT23:%.*]], {{!annotation ![0-9]+}}
// CHECK:       flex.base.nonnull:
// CHECK-NEXT:    [[TMP9:%.*]] = getelementptr [[STRUCT_FLEX_T]], ptr [[WIDE_PTR_PTR]], i64 1
// CHECK-NEXT:    [[TMP10:%.*]] = icmp ule ptr [[WIDE_PTR_PTR]], [[TMP9]], {{!annotation ![0-9]+}}
// CHECK-NEXT:    br i1 [[TMP10]], label [[CONT:%.*]], label [[TRAP:%.*]], {{!annotation ![0-9]+}}
// CHECK:       trap:
// CHECK-NEXT:    call void @llvm.ubsantrap(i8 25) #[[ATTR3]], {{!annotation ![0-9]+}}
// CHECK-NEXT:    unreachable
// CHECK:       cont:
// CHECK-NEXT:    call void @llvm.memcpy.p0.p0.i64(ptr align 8 [[AGG_TEMP3]], ptr align 8 [[AGG_TEMP]], i64 24, i1 false)
// CHECK-NEXT:    [[WIDE_PTR_PTR_ADDR4:%.*]] = getelementptr inbounds %"__bounds_safety::wide_ptr.bidi_indexable", ptr [[AGG_TEMP3]], i32 0, i32 0
// CHECK-NEXT:    [[WIDE_PTR_PTR5:%.*]] = load ptr, ptr [[WIDE_PTR_PTR_ADDR4]], align 8
// CHECK-NEXT:    [[WIDE_PTR_UB_ADDR6:%.*]] = getelementptr inbounds %"__bounds_safety::wide_ptr.bidi_indexable", ptr [[AGG_TEMP3]], i32 0, i32 1
// CHECK-NEXT:    [[WIDE_PTR_UB7:%.*]] = load ptr, ptr [[WIDE_PTR_UB_ADDR6]], align 8
// CHECK-NEXT:    [[WIDE_PTR_LB_ADDR8:%.*]] = getelementptr inbounds %"__bounds_safety::wide_ptr.bidi_indexable", ptr [[AGG_TEMP3]], i32 0, i32 2
// CHECK-NEXT:    [[WIDE_PTR_LB9:%.*]] = load ptr, ptr [[WIDE_PTR_LB_ADDR8]], align 8
// CHECK-NEXT:    [[TMP11:%.*]] = getelementptr [[STRUCT_FLEX_T]], ptr [[WIDE_PTR_PTR5]], i64 1
// CHECK-NEXT:    [[TMP12:%.*]] = icmp ule ptr [[TMP11]], [[WIDE_PTR_UB7]], {{!annotation ![0-9]+}}
// CHECK-NEXT:    br i1 [[TMP12]], label [[CONT11:%.*]], label [[TRAP10:%.*]], {{!annotation ![0-9]+}}
// CHECK:       trap10:
// CHECK-NEXT:    call void @llvm.ubsantrap(i8 25) #[[ATTR3]], {{!annotation ![0-9]+}}
// CHECK-NEXT:    unreachable
// CHECK:       cont11:
// CHECK-NEXT:    [[TMP13:%.*]] = icmp ule ptr [[WIDE_PTR_LB9]], [[WIDE_PTR_PTR5]], {{!annotation ![0-9]+}}
// CHECK-NEXT:    br i1 [[TMP13]], label [[CONT13:%.*]], label [[TRAP12:%.*]], {{!annotation ![0-9]+}}
// CHECK:       trap12:
// CHECK-NEXT:    call void @llvm.ubsantrap(i8 25) #[[ATTR3]], {{!annotation ![0-9]+}}
// CHECK-NEXT:    unreachable
// CHECK:       cont13:
// CHECK-NEXT:    [[ELEMS14:%.*]] = getelementptr inbounds [[STRUCT_FLEX_T]], ptr [[WIDE_PTR_PTR5]], i32 0, i32 1
// CHECK-NEXT:    [[ARRAYDECAY15:%.*]] = getelementptr inbounds [0 x i32], ptr [[ELEMS14]], i64 0, i64 0
// CHECK-NEXT:    br i1 true, label [[CONT17:%.*]], label [[TRAP16:%.*]], {{!annotation ![0-9]+}}
// CHECK:       trap16:
// CHECK-NEXT:    call void @llvm.ubsantrap(i8 25) #[[ATTR3]], {{!annotation ![0-9]+}}
// CHECK-NEXT:    unreachable, {{!annotation ![0-9]+}}
// CHECK:       cont17:
// CHECK-NEXT:    [[TMP14:%.*]] = icmp ule ptr [[ARRAYDECAY15]], [[WIDE_PTR_UB]], {{!annotation ![0-9]+}}
// CHECK-NEXT:    br i1 [[TMP14]], label [[CONT19:%.*]], label [[TRAP18:%.*]], {{!annotation ![0-9]+}}
// CHECK:       trap18:
// CHECK-NEXT:    call void @llvm.ubsantrap(i8 25) #[[ATTR3]], {{!annotation ![0-9]+}}
// CHECK-NEXT:    unreachable, {{!annotation ![0-9]+}}
// CHECK:       cont19:
// CHECK-NEXT:    [[TMP15:%.*]] = icmp uge ptr [[WIDE_PTR_PTR]], [[WIDE_PTR_LB]], {{!annotation ![0-9]+}}
// CHECK-NEXT:    br i1 [[TMP15]], label [[CONT21:%.*]], label [[TRAP20:%.*]], {{!annotation ![0-9]+}}
// CHECK:       trap20:
// CHECK-NEXT:    call void @llvm.ubsantrap(i8 25) #[[ATTR3]], {{!annotation ![0-9]+}}
// CHECK-NEXT:    unreachable, {{!annotation ![0-9]+}}
// CHECK:       cont21:
// CHECK-NEXT:    [[UPPER_INTPTR:%.*]] = ptrtoint ptr [[WIDE_PTR_UB]] to i64, {{!annotation ![0-9]+}}
// CHECK-NEXT:    [[FAM_INTPTR:%.*]] = ptrtoint ptr [[ARRAYDECAY15]] to i64, {{!annotation ![0-9]+}}
// CHECK-NEXT:    [[FLEX_AVAIL_COUNT:%.*]] = sub nuw i64 [[UPPER_INTPTR]], [[FAM_INTPTR]], {{!annotation ![0-9]+}}
// CHECK-NEXT:    [[FLEX_AVAIL_COUNT_DIV:%.*]] = sdiv exact i64 [[FLEX_AVAIL_COUNT]], 4, {{!annotation ![0-9]+}}
// CHECK-NEXT:    [[FLEX_COUNT_CHECK:%.*]] = icmp ule i64 10, [[FLEX_AVAIL_COUNT_DIV]], {{!annotation ![0-9]+}}
// CHECK-NEXT:    br i1 [[FLEX_COUNT_CHECK]], label [[CONT23]], label [[TRAP22:%.*]], {{!annotation ![0-9]+}}
// CHECK:       trap22:
// CHECK-NEXT:    call void @llvm.ubsantrap(i8 25) #[[ATTR3]], {{!annotation ![0-9]+}}
// CHECK-NEXT:    unreachable, {{!annotation ![0-9]+}}
// CHECK:       cont23:
// CHECK-NEXT:    call void @llvm.memcpy.p0.p0.i64(ptr align 8 [[AGG_TEMP1]], ptr align 8 [[AGG_TEMP]], i64 24, i1 false)
// CHECK-NEXT:    [[WIDE_PTR_PTR_ADDR24:%.*]] = getelementptr inbounds %"__bounds_safety::wide_ptr.bidi_indexable", ptr [[AGG_TEMP1]], i32 0, i32 0
// CHECK-NEXT:    [[WIDE_PTR_PTR25:%.*]] = load ptr, ptr [[WIDE_PTR_PTR_ADDR24]], align 8
// CHECK-NEXT:    [[WIDE_PTR_UB_ADDR26:%.*]] = getelementptr inbounds %"__bounds_safety::wide_ptr.bidi_indexable", ptr [[AGG_TEMP1]], i32 0, i32 1
// CHECK-NEXT:    [[WIDE_PTR_UB27:%.*]] = load ptr, ptr [[WIDE_PTR_UB_ADDR26]], align 8
// CHECK-NEXT:    [[WIDE_PTR_LB_ADDR28:%.*]] = getelementptr inbounds %"__bounds_safety::wide_ptr.bidi_indexable", ptr [[AGG_TEMP1]], i32 0, i32 2
// CHECK-NEXT:    [[WIDE_PTR_LB29:%.*]] = load ptr, ptr [[WIDE_PTR_LB_ADDR28]], align 8
// CHECK-NEXT:    [[TMP16:%.*]] = icmp ne ptr [[WIDE_PTR_PTR25]], null, {{!annotation ![0-9]+}}
// CHECK-NEXT:    br i1 [[TMP16]], label [[BOUNDSCHECK_NOTNULL30:%.*]], label [[CONT34:%.*]], {{!annotation ![0-9]+}}
// CHECK:       boundscheck.notnull30:
// CHECK-NEXT:    [[TMP17:%.*]] = icmp ult ptr [[WIDE_PTR_PTR25]], [[WIDE_PTR_UB27]], {{!annotation ![0-9]+}}
// CHECK-NEXT:    br i1 [[TMP17]], label [[CONT32:%.*]], label [[TRAP31:%.*]], {{!annotation ![0-9]+}}
// CHECK:       trap31:
// CHECK-NEXT:    call void @llvm.ubsantrap(i8 25) #[[ATTR3]], {{!annotation ![0-9]+}}
// CHECK-NEXT:    unreachable
// CHECK:       cont32:
// CHECK-NEXT:    [[TMP18:%.*]] = icmp uge ptr [[WIDE_PTR_PTR25]], [[WIDE_PTR_LB29]], {{!annotation ![0-9]+}}
// CHECK-NEXT:    br i1 [[TMP18]], label [[CONT34]], label [[TRAP33:%.*]], {{!annotation ![0-9]+}}
// CHECK:       trap33:
// CHECK-NEXT:    call void @llvm.ubsantrap(i8 25) #[[ATTR3]], {{!annotation ![0-9]+}}
// CHECK-NEXT:    unreachable
// CHECK:       cont34:
// CHECK-NEXT:    store ptr [[WIDE_PTR_PTR25]], ptr [[B]], align 8
// CHECK-NEXT:    [[TMP19:%.*]] = load ptr, ptr [[B]], align 8
// CHECK-NEXT:    [[COUNT35:%.*]] = getelementptr inbounds [[STRUCT_FLEX_T]], ptr [[TMP19]], i32 0, i32 0
// CHECK-NEXT:    store i32 10, ptr [[COUNT35]], align 4
// CHECK-NEXT:    ret void
//
void pointer_and_count_assign_single(flex_t *flex) {
  flex_t *__single b = flex;
  b->count = 10;
}
