// NOTE: Assertions have been autogenerated by utils/update_cc_test_checks.py UTC_ARGS: --version 2
// RUN: %clang_cc1 -O0 -triple arm64-apple-iphoneos -fbounds-safety -Wno-error=bounds-safety-strict-terminated-by-cast -emit-llvm %s -o - | FileCheck %s

#include <ptrcheck.h>

// This should be removed by rdar://118390724
// Until then this is here to make sure that Sema retains a valid AST when emitted as warning, so that CodeGen doesn't crash

void foo(const char * __null_terminated);
void bar(const char * __null_terminated * __single);

// CHECK-LABEL: define dso_local void @test
// CHECK-SAME: (ptr noundef [[SP:%.*]]) #[[ATTR0:[0-9]+]] {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[SP_ADDR:%.*]] = alloca ptr, align 8
// CHECK-NEXT:    [[NTP:%.*]] = alloca ptr, align 8
// CHECK-NEXT:    [[NTP2:%.*]] = alloca ptr, align 8
// CHECK-NEXT:    [[NTP3:%.*]] = alloca ptr, align 8
// CHECK-NEXT:    [[SPP:%.*]] = alloca ptr, align 8
// CHECK-NEXT:    [[AGG_TEMP:%.*]] = alloca %"__bounds_safety::wide_ptr.bidi_indexable", align 8
// CHECK-NEXT:    [[NTPP:%.*]] = alloca ptr, align 8
// CHECK-NEXT:    [[NTPP2:%.*]] = alloca ptr, align 8
// CHECK-NEXT:    [[NTPP3:%.*]] = alloca ptr, align 8
// CHECK-NEXT:    store ptr [[SP]], ptr [[SP_ADDR]], align 8
// CHECK-NEXT:    [[TMP0:%.*]] = load ptr, ptr [[SP_ADDR]], align 8
// CHECK-NEXT:    store ptr [[TMP0]], ptr [[NTP]], align 8
// CHECK-NEXT:    [[TMP1:%.*]] = load ptr, ptr [[SP_ADDR]], align 8
// CHECK-NEXT:    store ptr [[TMP1]], ptr [[NTP2]], align 8
// CHECK-NEXT:    [[TMP2:%.*]] = load ptr, ptr [[SP_ADDR]], align 8
// CHECK-NEXT:    call void @foo(ptr noundef [[TMP2]])
// CHECK-NEXT:    [[TMP3:%.*]] = load ptr, ptr [[SP_ADDR]], align 8
// CHECK-NEXT:    call void @foo(ptr noundef [[TMP3]])
// CHECK-NEXT:    [[TMP4:%.*]] = load ptr, ptr [[NTP]], align 8
// CHECK-NEXT:    store ptr [[TMP4]], ptr [[NTP3]], align 8
// CHECK-NEXT:    [[TMP5:%.*]] = load ptr, ptr [[SP_ADDR]], align 8
// CHECK-NEXT:    store ptr [[TMP5]], ptr [[NTP3]], align 8
// CHECK-NEXT:    [[TMP6:%.*]] = load ptr, ptr [[SP_ADDR]], align 8
// CHECK-NEXT:    store ptr [[TMP6]], ptr [[NTP3]], align 8
// CHECK-NEXT:    [[TMP7:%.*]] = getelementptr ptr, ptr [[SP_ADDR]], i64 1
// CHECK-NEXT:    [[TMP8:%.*]] = getelementptr inbounds %"__bounds_safety::wide_ptr.bidi_indexable", ptr [[AGG_TEMP]], i32 0, i32 0
// CHECK-NEXT:    store ptr [[SP_ADDR]], ptr [[TMP8]], align 8
// CHECK-NEXT:    [[TMP9:%.*]] = getelementptr inbounds %"__bounds_safety::wide_ptr.bidi_indexable", ptr [[AGG_TEMP]], i32 0, i32 1
// CHECK-NEXT:    store ptr [[TMP7]], ptr [[TMP9]], align 8
// CHECK-NEXT:    [[TMP10:%.*]] = getelementptr inbounds %"__bounds_safety::wide_ptr.bidi_indexable", ptr [[AGG_TEMP]], i32 0, i32 2
// CHECK-NEXT:    store ptr [[SP_ADDR]], ptr [[TMP10]], align 8
// CHECK-NEXT:    [[WIDE_PTR_PTR_ADDR:%.*]] = getelementptr inbounds %"__bounds_safety::wide_ptr.bidi_indexable", ptr [[AGG_TEMP]], i32 0, i32 0
// CHECK-NEXT:    [[WIDE_PTR_PTR:%.*]] = load ptr, ptr [[WIDE_PTR_PTR_ADDR]], align 8
// CHECK-NEXT:    [[WIDE_PTR_UB_ADDR:%.*]] = getelementptr inbounds %"__bounds_safety::wide_ptr.bidi_indexable", ptr [[AGG_TEMP]], i32 0, i32 1
// CHECK-NEXT:    [[WIDE_PTR_UB:%.*]] = load ptr, ptr [[WIDE_PTR_UB_ADDR]], align 8
// CHECK-NEXT:    [[WIDE_PTR_LB_ADDR:%.*]] = getelementptr inbounds %"__bounds_safety::wide_ptr.bidi_indexable", ptr [[AGG_TEMP]], i32 0, i32 2
// CHECK-NEXT:    [[WIDE_PTR_LB:%.*]] = load ptr, ptr [[WIDE_PTR_LB_ADDR]], align 8
// CHECK-NEXT:    [[TMP11:%.*]] = icmp ne ptr [[WIDE_PTR_PTR]], null
// CHECK-NEXT:    br i1 [[TMP11]], label [[BOUNDSCHECK_NOTNULL:%.*]], label [[CONT2:%.*]],
// CHECK:       boundscheck.notnull:
// CHECK-NEXT:    [[TMP12:%.*]] = icmp ult ptr [[WIDE_PTR_PTR]], [[WIDE_PTR_UB]]
// CHECK-NEXT:    br i1 [[TMP12]], label [[CONT:%.*]], label [[TRAP:%.*]]
// CHECK:       trap:
// CHECK-NEXT:    call void @llvm.ubsantrap(i8 25) #[[ATTR3:[0-9]+]]
// CHECK-NEXT:    unreachable
// CHECK:       cont:
// CHECK-NEXT:    [[TMP13:%.*]] = icmp uge ptr [[WIDE_PTR_PTR]], [[WIDE_PTR_LB]]
// CHECK-NEXT:    br i1 [[TMP13]], label [[CONT2]], label [[TRAP1:%.*]]
// CHECK:       trap1:
// CHECK-NEXT:    call void @llvm.ubsantrap(i8 25) #[[ATTR3]]
// CHECK-NEXT:    unreachable
// CHECK:       cont2:
// CHECK-NEXT:    store ptr [[WIDE_PTR_PTR]], ptr [[SPP]], align 8
// CHECK-NEXT:    [[TMP14:%.*]] = load ptr, ptr [[SPP]], align 8
// CHECK-NEXT:    store ptr [[TMP14]], ptr [[NTPP]], align 8
// CHECK-NEXT:    [[TMP15:%.*]] = load ptr, ptr [[SPP]], align 8
// CHECK-NEXT:    store ptr [[TMP15]], ptr [[NTPP2]], align 8
// CHECK-NEXT:    [[TMP16:%.*]] = load ptr, ptr [[SPP]], align 8
// CHECK-NEXT:    call void @bar(ptr noundef [[TMP16]])
// CHECK-NEXT:    [[TMP17:%.*]] = load ptr, ptr [[SPP]], align 8
// CHECK-NEXT:    call void @bar(ptr noundef [[TMP17]])
// CHECK-NEXT:    [[TMP18:%.*]] = load ptr, ptr [[NTPP]], align 8
// CHECK-NEXT:    store ptr [[TMP18]], ptr [[NTPP3]], align 8
// CHECK-NEXT:    [[TMP19:%.*]] = load ptr, ptr [[SPP]], align 8
// CHECK-NEXT:    store ptr [[TMP19]], ptr [[NTPP3]], align 8
// CHECK-NEXT:    [[TMP20:%.*]] = load ptr, ptr [[SPP]], align 8
// CHECK-NEXT:    store ptr [[TMP20]], ptr [[NTPP3]], align 8
// CHECK-NEXT:    ret void
//
void test(const char * __single sp) {
    const char * __null_terminated ntp = sp;
    const char * __null_terminated ntp2 = (const char * __null_terminated) sp;

    foo(sp);
    foo((const char * __null_terminated) sp);

    const char * __null_terminated ntp3 = ntp;
    ntp3 = sp;
    ntp3 = (const char * __null_terminated) sp;


    /* --- Nested --- */

    const char * __single * __single spp = &sp;
    const char * __null_terminated * __single ntpp = spp;
    const char * __null_terminated * __single ntpp2 = (const char * __null_terminated * __single) spp;

    bar(spp);
    bar((const char * __null_terminated * __single) spp);

    const char * __null_terminated * __single ntpp3 = ntpp;
    ntpp3 = spp;
    ntpp3 = (const char * __null_terminated * __single) spp;
}
