// NOTE: Assertions have been autogenerated by utils/update_cc_test_checks.py UTC_ARGS: --replace-value-regex "!annotation ![0-9]+" "!tbaa ![0-9]+" "!tbaa\.struct ![0-9]+" "!nosanitize ![0-9]+" "!srcloc ![0-9]+" --prefix-filecheck-ir-name TMP_ --version 3

// RUN: %clang_cc1 -O2 -triple x86_64 -fbounds-safety -fprofile-instrument=clang -fcoverage-mapping -emit-llvm %s -o - | FileCheck %s

#include <ptrcheck.h>

struct s {
    int count;
    int fam[__counted_by(count)];
};

void bar(struct s *p);

// CHECK-LABEL: define dso_local void @foo(
// CHECK-SAME: ptr noundef [[BUF:%.*]], i32 noundef [[SIZE:%.*]]) local_unnamed_addr #[[ATTR0:[0-9]+]] {
// CHECK-NEXT:  entry:
// CHECK-NEXT:    [[PGOCOUNT:%.*]] = load i64, ptr @__profc_foo, align 8
// CHECK-NEXT:    [[TMP0:%.*]] = add i64 [[PGOCOUNT]], 1
// CHECK-NEXT:    store i64 [[TMP0]], ptr @__profc_foo, align 8
// CHECK-NEXT:    [[IDX_EXT:%.*]] = zext i32 [[SIZE]] to i64
// CHECK-NEXT:    [[FLEX_BASE_NULL_CHECK_NOT:%.*]] = icmp eq ptr [[BUF]], null, {{!annotation ![0-9]+}}
// CHECK-NEXT:    br i1 [[FLEX_BASE_NULL_CHECK_NOT]], label [[CONT40:%.*]], label [[FLEX_BASE_NONNULL:%.*]], {{!annotation ![0-9]+}}
// CHECK:       flex.base.nonnull:
// CHECK-NEXT:    [[ADD_PTR:%.*]] = getelementptr inbounds i8, ptr [[BUF]], i64 [[IDX_EXT]]
// CHECK-NEXT:    [[TMP1:%.*]] = getelementptr i8, ptr [[BUF]], i64 4
// CHECK-NEXT:    [[DOTNOT:%.*]] = icmp ult ptr [[TMP1]], [[BUF]], {{!annotation ![0-9]+}}
// CHECK-NEXT:    [[DOTNOT49:%.*]] = icmp ugt ptr [[TMP1]], [[ADD_PTR]], {{!annotation ![0-9]+}}
// CHECK-NEXT:    [[OR_COND:%.*]] = select i1 [[DOTNOT]], i1 true, i1 [[DOTNOT49]], {{!annotation ![0-9]+}}
// CHECK-NEXT:    br i1 [[OR_COND]], label [[TRAP:%.*]], label [[CONT27:%.*]], {{!annotation ![0-9]+}}
// CHECK:       trap:
// CHECK-NEXT:    tail call void @llvm.ubsantrap(i8 25) #[[ATTR3:[0-9]+]], {{!annotation ![0-9]+}}
// CHECK-NEXT:    unreachable, {{!annotation ![0-9]+}}
// CHECK:       cont27:
// CHECK-NEXT:    [[TMP2:%.*]] = load i32, ptr [[BUF]], align 4, {{!tbaa ![0-9]+}}
// CHECK-NEXT:    [[FLEX_COUNT_MINUS:%.*]] = icmp sgt i32 [[TMP2]], -1, {{!annotation ![0-9]+}}
// CHECK-NEXT:    br i1 [[FLEX_COUNT_MINUS]], label [[CONT30:%.*]], label [[TRAP]], {{!annotation ![0-9]+}}
// CHECK:       cont30:
// CHECK-NEXT:    [[GEPDIFF:%.*]] = add nsw i64 [[IDX_EXT]], -4, {{!annotation ![0-9]+}}
// CHECK-NEXT:    [[FLEX_AVAIL_COUNT_DIV:%.*]] = ashr exact i64 [[GEPDIFF]], 2, {{!annotation ![0-9]+}}
// CHECK-NEXT:    [[FLEX_COUNT_INTPTR:%.*]] = zext nneg i32 [[TMP2]] to i64, {{!annotation ![0-9]+}}
// CHECK-NEXT:    [[FLEX_COUNT_CHECK_NOT:%.*]] = icmp ult i64 [[FLEX_AVAIL_COUNT_DIV]], [[FLEX_COUNT_INTPTR]], {{!annotation ![0-9]+}}
// CHECK-NEXT:    [[DOTNOT50:%.*]] = icmp eq i32 [[SIZE]], 0, {{!annotation ![0-9]+}}
// CHECK-NEXT:    [[OR_COND52:%.*]] = or i1 [[DOTNOT50]], [[FLEX_COUNT_CHECK_NOT]], {{!annotation ![0-9]+}}
// CHECK-NEXT:    br i1 [[OR_COND52]], label [[TRAP]], label [[CONT40]], {{!annotation ![0-9]+}}
// CHECK:       cont40:
// CHECK-NEXT:    tail call void @bar(ptr noundef [[BUF]]) #[[ATTR4:[0-9]+]]
// CHECK-NEXT:    ret void
//
void foo(void *__sized_by(size) buf, unsigned size) {
    struct s *p = (struct s *)buf;
    bar(p);
}
