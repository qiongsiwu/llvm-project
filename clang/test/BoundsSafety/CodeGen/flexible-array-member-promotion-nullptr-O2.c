// NOTE: Assertions have been autogenerated by utils/update_cc_test_checks.py UTC_ARGS: --replace-value-regex "!annotation ![0-9]+" "!tbaa ![0-9]+" "!tbaa\.struct ![0-9]+" "!nosanitize ![0-9]+" "!srcloc ![0-9]+" --prefix-filecheck-ir-name TMP_
// RUN: %clang_cc1 -O2 -triple arm64-apple-iphoneos -fbounds-safety -emit-llvm %s -o - | FileCheck %s
// RUN: %clang_cc1 -O2 -triple arm64-apple-iphoneos -fbounds-safety -x objective-c -fexperimental-bounds-safety-objc -emit-llvm %s -o - | FileCheck %s

#include <ptrcheck.h>

typedef struct {
  int count;
  int elems[__counted_by(count)];
} flex_t;

typedef struct {
  flex_t *f;
} wflex_t;

// CHECK-LABEL: @null_init(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    ret void
//
void null_init(void) {
  wflex_t b = {0};
  flex_t *f = b.f;
}

// CHECK-LABEL: @null_assign(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    ret void
//
void null_assign(void) {
  wflex_t b = {0};
  flex_t *f;
  f = b.f;
}

// CHECK-LABEL: @null_init_assign(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    ret void
//
void null_init_assign(void) {
  wflex_t b = {0};
  flex_t *f = 0;
  f = b.f;
}

// CHECK-LABEL: @null_init_ret(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    ret ptr null
//
flex_t *null_init_ret(void) {
  wflex_t b = {0};
  flex_t *f = b.f;
  return f;
}

// CHECK-LABEL: @null_assign_ret(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    ret ptr null
//
flex_t *null_assign_ret(void) {
  wflex_t b = {0};
  flex_t *f = 0;
  return f = b.f;
}

// CHECK-LABEL: @null_init_single(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    ret void
//
void null_init_single(void) {
  wflex_t b = {0};
  flex_t *__single f = b.f;
}

// CHECK-LABEL: @null_assign_single(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    ret void
//
void null_assign_single(void) {
  wflex_t b = {0};
  flex_t *__single f = 0;
  f = b.f;
}

// CHECK-LABEL: @null_init_single_ret(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    ret ptr null
//
flex_t *null_init_single_ret(void) {
  wflex_t b = {0};
  flex_t *__single f = b.f;
  return f;
}

// CHECK-LABEL: @null_init_bidi_to_single(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    ret void
//
void null_init_bidi_to_single(void) {
  wflex_t b = {0};
  flex_t *f = b.f;
  flex_t *__single f2 = f;
}


typedef struct {
  int dummy;
  flex_t inner;
} flex_wrap_t;

// CHECK-LABEL: @nested_init(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    ret void
//
void nested_init(void) {
  flex_wrap_t *a = 0;
  flex_wrap_t *__single b = a;
}


// CHECK-LABEL: @nested_assign(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    ret void
//
void nested_assign(void) {
  flex_wrap_t *a = 0;
  flex_wrap_t *__single b = 0;
  b = a;
}

// CHECK-LABEL: @nested_single_to_single(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    ret void
//
void nested_single_to_single(void) {
  flex_wrap_t *__single a = 0;
  flex_wrap_t *__single b = 0;
  b = a;
}

static inline flex_wrap_t *accept_flex(flex_wrap_t *p) {
  flex_wrap_t *__single a = p;
  return a;
}

// CHECK-LABEL: @pass_zero_to_flex(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    ret void
//
void pass_zero_to_flex(void) {
  accept_flex(0);
}


// CHECK-LABEL: @nested_return(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    ret ptr null
//
flex_wrap_t *nested_return(void) {
  flex_wrap_t *a = 0;
  return a;
}
