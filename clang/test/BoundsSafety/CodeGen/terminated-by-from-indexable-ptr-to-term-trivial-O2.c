// NOTE: Assertions have been autogenerated by utils/update_cc_test_checks.py UTC_ARGS: --replace-value-regex "!annotation ![0-9]+" "!tbaa ![0-9]+" "!tbaa\.struct ![0-9]+" "!nosanitize ![0-9]+" "!srcloc ![0-9]+"
// RUN: %clang_cc1 -O2 -triple x86_64 -fbounds-safety -emit-llvm %s -o - | FileCheck %s
// RUN: %clang_cc1 -O2 -triple x86_64 -fbounds-safety -x objective-c -fexperimental-bounds-safety-objc -emit-llvm %s -o - | FileCheck %s

#include <ptrcheck.h>
#include <stdint.h>

static const struct {
  int _dummy;
  // We use int32_t instead of int, because we want a type whose size is greater than 1.
  int32_t ints[3];
} foo = {
    0,
    {1, 2, 3},
};

// CHECK-LABEL: @good(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    ret ptr getelementptr inbounds (i8, ptr @foo, i64 4)
//
const int32_t *__terminated_by(3) good(void) {
  const int32_t *__indexable p = foo.ints;
  return __unsafe_terminated_by_from_indexable(3, p, p + 2);
}

// CHECK-LABEL: @bad_no_term(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    tail call void @llvm.ubsantrap(i8 25) #[[ATTR3:[0-9]+]], {{!annotation ![0-9]+}}
// CHECK-NEXT:    unreachable, {{!annotation ![0-9]+}}
//
const int32_t *__terminated_by(3) bad_no_term(void) {
  const int32_t *__indexable p = foo.ints;
  return __unsafe_terminated_by_from_indexable(3, p, p);
}

// CHECK-LABEL: @bad_ptr_to_term_oob(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    tail call void @llvm.ubsantrap(i8 25) #[[ATTR3]], {{!annotation ![0-9]+}}
// CHECK-NEXT:    unreachable, {{!annotation ![0-9]+}}
//
const int32_t *__terminated_by(3) bad_ptr_to_term_oob(void) {
  const int32_t *__indexable p = foo.ints;
  return __unsafe_terminated_by_from_indexable(3, p, p + 3);
}

// CHECK-LABEL: @bad_ptr_to_term_oob2(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    tail call void @llvm.ubsantrap(i8 25) #[[ATTR3]], {{!annotation ![0-9]+}}
// CHECK-NEXT:    unreachable, {{!annotation ![0-9]+}}
//
const int32_t *__terminated_by(3) bad_ptr_to_term_oob2(void) {
  const int32_t *__indexable p = foo.ints;
  const int32_t *__bidi_indexable q = p;
  return __unsafe_terminated_by_from_indexable(3, p, q - 1);
}

// CHECK-LABEL: @bad_ptr_to_term_oob3(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    tail call void @llvm.ubsantrap(i8 25) #[[ATTR3]], {{!annotation ![0-9]+}}
// CHECK-NEXT:    unreachable, {{!annotation ![0-9]+}}
//
const int32_t *__terminated_by(3) bad_ptr_to_term_oob3(void) {
  const int32_t *__indexable p = foo.ints;
  const int32_t *__bidi_indexable q = (const void *__bidi_indexable)p + sizeof(foo.ints) - 1;
  return __unsafe_terminated_by_from_indexable(3, p, q);
}
