// NOTE: Assertions have been autogenerated by utils/update_cc_test_checks.py UTC_ARGS: --replace-value-regex "!annotation ![0-9]+" "!tbaa ![0-9]+" "!tbaa\.struct ![0-9]+" "!nosanitize ![0-9]+" "!srcloc ![0-9]+"

// RUN: %clang_cc1 -triple x86_64 -fbounds-safety -emit-llvm %s -o - | FileCheck %s --check-prefix=X86_64
// RUN: %clang_cc1 -triple aarch64 -fbounds-safety -emit-llvm %s -o - | FileCheck %s --check-prefix=AARCH64
// RUN: %clang_cc1 -triple i686 -fbounds-safety -emit-llvm %s -o - | FileCheck %s --check-prefix=I686
// RUN: %clang_cc1 -triple x86_64 -fbounds-safety -x objective-c -fexperimental-bounds-safety-objc -emit-llvm %s -o - | FileCheck %s --check-prefix=X86_64
// RUN: %clang_cc1 -triple aarch64 -fbounds-safety -x objective-c -fexperimental-bounds-safety-objc -emit-llvm %s -o - | FileCheck %s --check-prefix=AARCH64
// RUN: %clang_cc1 -triple i686 -fbounds-safety -x objective-c -fexperimental-bounds-safety-objc -emit-llvm %s -o - | FileCheck %s --check-prefix=I686

#include <ptrcheck.h>

// X86_64-LABEL: @foo(
// X86_64-NEXT:  entry:
// X86_64-NEXT:    call void @llvm.memcpy.p0.p0.i64(ptr align 8 [[AGG_RESULT:%.*]], ptr align 8 [[PTRARG:%.*]], i64 24, i1 false)
// X86_64-NEXT:    ret void
//
// AARCH64-LABEL: @foo(
// AARCH64-NEXT:  entry:
// AARCH64-NEXT:    [[PTRARG_INDIRECT_ADDR:%.*]] = alloca ptr, align 8
// AARCH64-NEXT:    store ptr [[PTRARG:%.*]], ptr [[PTRARG_INDIRECT_ADDR]], align 8
// AARCH64-NEXT:    call void @llvm.memcpy.p0.p0.i64(ptr align 8 [[AGG_RESULT:%.*]], ptr align 8 [[PTRARG]], i64 24, i1 false)
// AARCH64-NEXT:    ret void
//
// I686-LABEL: @foo(
// I686-NEXT:  entry:
// I686-NEXT:    [[RESULT_PTR:%.*]] = alloca ptr, align 4
// I686-NEXT:    store ptr [[AGG_RESULT:%.*]], ptr [[RESULT_PTR]], align 4
// I686-NEXT:    call void @llvm.memcpy.p0.p0.i32(ptr align 4 [[AGG_RESULT]], ptr align 4 [[PTRARG:%.*]], i32 12, i1 false)
// I686-NEXT:    ret void
//
int*__bidi_indexable foo(int *__bidi_indexable ptrArg) {
    return ptrArg;
}






