// NOTE: Assertions have been autogenerated by utils/update_cc_test_checks.py UTC_ARGS: --replace-value-regex "!annotation ![0-9]+" "!tbaa ![0-9]+" "!tbaa\.struct ![0-9]+" "!nosanitize ![0-9]+" "!srcloc ![0-9]+"
// RUN: %clang_cc1 -O2  -fbounds-safety -emit-llvm -triple x86_64 %s -o - | FileCheck %s
// RUN: %clang_cc1 -O2  -fbounds-safety -x objective-c -fexperimental-bounds-safety-objc -emit-llvm -triple x86_64 %s -o - | FileCheck %s
#include <ptrcheck.h>

struct S {
    int *__ended_by(end) iter;
    int *end;
    int *__ended_by(iter) start;
};

struct T {
    int cnt;
    int *__counted_by(cnt) ptr;
};

// CHECK-LABEL: @TestIterOK(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    ret i32 0
//
int TestIterOK() {
    int arr[10];
    struct S s = { arr, arr + 10, arr };
    struct T t = { 2, arr + 1 };
    s.start = s.start;
    s.iter = t.ptr; // this passes as 's.start <= t.ptr <= s.end'
    s.end = s.end;
    return 0;
}

// CHECK-LABEL: @TestIterOK2(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    ret i32 0
//
int TestIterOK2() {
  int arr[10];
  struct S s = { arr, arr + 6, arr };
  struct T t = { 4, arr + 6 };
  s.start = s.start;
  s.iter = t.ptr;
  s.end = s.end;
  return 0;
}

// CHECK-LABEL: @TestIterFail(
// CHECK-NEXT:  entry:
// CHECK-NEXT:    tail call void @llvm.ubsantrap(i8 25) #[[ATTR3:[0-9]+]], {{!annotation ![0-9]+}}
// CHECK-NEXT:    unreachable
//
int TestIterFail() {
  int arr[10];
  struct S s = { arr, arr + 5, arr };
  struct T t = { 4, arr + 6 };
  s.start = s.start;
  s.iter = t.ptr;
  s.end = s.end;
  return 0;
}
